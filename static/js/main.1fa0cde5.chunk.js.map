{"version":3,"sources":["components/Toolbar.tsx","components/Cropper.tsx","components/Video.tsx","state.ts","export.ts","App.tsx","utils/useContainerDimensions.tsx","serviceWorker.ts","index.tsx"],"names":["Toolbar","state","dispatch","startCapture","stopCapture","durationSecs","onExport","base64","btoa","Uint8Array","png","reduce","data","byte","String","fromCharCode","disabled","isRecording","onClick","icon","align","Alignment","RIGHT","type","minimal","content","text","isConverting","map","width","key","gifWidth","screenDimensions","gif","download","href","target","style","value","progress","numeral","format","Reactable","reactable","props","ref","getRef","position","left","x","top","y","height","touchAction","borderWidth","borderColor","borderStyle","pointerEvents","onCrop","onCropCancel","Cropper","onCancel","React","useState","coordinate","setCoordinate","resizable","edges","right","bottom","modifiers","interact","restrictRect","restriction","draggable","onDragMove","event","prev","dx","dy","onResizeMove","e","rect","deltaRect","Video","frames","displayWidth","displayHeight","canvasRef","useRef","useEffect","frameIndex","timeStarted","Date","now","ctx","current","getContext","requestAnimationFrame","draw","timestamp","putImageData","imageData","length","play","maxHeight","maxWidth","margin","initialState","chunks","chunksUrl","isCropping","cropDimensions","hasData","reducer","action","chunk","URL","createObjectURL","captureStream","getVideoTracks","getSettings","dimensions","GIFExporter","encoder","this","GifEncoder","highWaterMark","writeHeader","delay","addFrame","finish","read","PNGExporter","dels","del","push","UPNG","encode","captureDisplay","displayMediaOptions","a","navigator","mediaDevices","getDisplayMedia","console","error","video","cursor","audio","App","useReducer","mediaRecorder","setMediaRecorder","startTime","setStartTime","stopTime","setStopTime","currentTime","setCurrentTime","frameTimer","window","onbeforeunload","document","createElement","canvas","context","srcObject","captureStartTime","onloadeddata","setInterval","videoWidth","videoHeight","log","drawImage","getImageData","_mediaRecorder","MediaRecorder","ondataavailable","onstop","start","stop","clearInterval","videoRef","myRef","getDimensions","offsetWidth","offsetHeight","setDimensions","handleResize","addEventListener","removeEventListener","useContainerDimensions","screenWidth","screenHeight","browserAspectRatio","videoAspectRatio","videoLeft","videoTop","scaledHeight","scaledWidth","setTimeout","className","scaleFactorX","scaleFactorY","Math","round","sourceWidth","sourceHeight","targetWidth","targetHeight","onImageProgress","onImageComplete","exporter","buffer","bufferContext","canvasContext","render","frame","scaledFrame","lastFrameTimestamp","exportImage","padding","backgroundColor","display","title","description","undefined","Boolean","location","hostname","match","ReactDOM","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.1fa0cde5.chunk.js","sourcesContent":["import React from \"react\";\nimport {\n  MenuItem,\n  Menu,\n  NavbarDivider,\n  Popover,\n  NavbarGroup,\n  Navbar,\n  Button,\n  ProgressBar,\n  NavbarHeading,\n  Alignment,\n  MenuDivider,\n} from \"@blueprintjs/core\";\nimport numeral from \"numeral\";\nimport { State, Action } from \"../state\";\n\nexport const Toolbar = ({\n  state,\n  dispatch,\n  startCapture,\n  stopCapture,\n  durationSecs,\n  onExport,\n}: {\n  state: State;\n  dispatch: React.Dispatch<Action>;\n  startCapture: any;\n  stopCapture: any;\n  durationSecs: number;\n  onExport: any;\n}) => {\n  const base64 = btoa(\n    new Uint8Array(state.png).reduce(\n      (data, byte) => data + String.fromCharCode(byte),\n      \"\"\n    )\n  );\n\n  const imageWidths = [256, 512, 1024, 2048];\n\n  return (\n    <Navbar>\n      <NavbarGroup>\n        <NavbarHeading>\n          <h3>screencatcher</h3>\n        </NavbarHeading>\n        <Button\n          disabled={state.isRecording}\n          onClick={startCapture}\n          icon=\"record\"\n        >\n          Record\n        </Button>\n        <Button disabled={!state.isRecording} onClick={stopCapture} icon=\"stop\">\n          Stop\n        </Button>\n      </NavbarGroup>\n\n      <NavbarGroup align={Alignment.RIGHT}>\n        <Button\n          icon=\"zoom-to-fit\"\n          onClick={() => dispatch({ type: \"startCropping\" })}\n        >\n          Crop\n        </Button>\n        <NavbarDivider />\n        <Popover\n          minimal\n          content={\n            <Menu>\n              <MenuItem\n                text=\"Export to PNG\"\n                disabled={state.isConverting}\n                onClick={() => onExport(\"png\")}\n              />\n              <MenuItem\n                text=\"Export to GIF\"\n                disabled={state.isConverting}\n                onClick={() => onExport(\"gif\")}\n              />\n              <MenuDivider />\n\n              <MenuItem text=\"Image Width\">\n                {imageWidths.map((width: number) => (\n                  <MenuItem\n                    key={width}\n                    text={`${width}`}\n                    icon={state.gifWidth === width ? \"tick\" : null}\n                    onClick={() => dispatch({ type: \"setGifWidth\", width })}\n                  />\n                ))}\n                {state.screenDimensions && (\n                  <MenuItem\n                    key={\"original\"}\n                    text={`Original: ${state.screenDimensions?.[0]}`}\n                    icon={\n                      state.gifWidth === state.screenDimensions?.[0]\n                        ? \"tick\"\n                        : null\n                    }\n                    onClick={() =>\n                      dispatch({\n                        type: \"setGifWidth\",\n                        width: state.screenDimensions![0],\n                      })\n                    }\n                  />\n                )}\n              </MenuItem>\n            </Menu>\n          }\n        >\n          <Button icon=\"export\" text=\"Export...\" />\n        </Popover>\n        {(state.png || state.gif) && (\n          <Popover\n            minimal\n            content={\n              <Menu>\n                <MenuItem\n                  text=\"Download PNG\"\n                  download=\"screencatcher.png\"\n                  href={`data:image/png;base64,${base64}`}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!state.png}\n                />\n                <MenuItem\n                  text=\"Download GIF\"\n                  download=\"screencatcher.gif\"\n                  href={`data:image/gif;base64,${state.gif}`}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!state.gif}\n                />\n              </Menu>\n            }\n          >\n            <Button icon=\"download\" text=\"Download...\" />\n          </Popover>\n        )}\n        {state.isConverting && (\n          <>\n            <NavbarDivider />\n            <div style={{ width: \"10rem\" }}>\n              <ProgressBar value={state.progress} />\n            </div>\n          </>\n        )}\n        <NavbarDivider />\n        Duration: {numeral(durationSecs > 0 ? durationSecs : 0).format(\"0.0\")}s\n      </NavbarGroup>\n    </Navbar>\n  );\n};\n","import React from \"react\";\nimport { Button } from \"@blueprintjs/core\";\nimport reactable from \"reactablejs\";\nimport interact from \"interactjs\";\n\nconst Demo = (props: any) => (\n  <div\n    ref={props.getRef}\n    style={{\n      position: \"absolute\",\n      left: props.x,\n      top: props.y,\n      width: props.width,\n      height: props.height,\n      touchAction: \"none\",\n      borderWidth: 5,\n      borderColor: \"red\",\n      borderStyle: \"solid\",\n      pointerEvents: \"all\",\n    }}\n  >\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      {props.x},{props.y},{props.width},{props.height}{\" \"}\n      <Button\n        onClick={() =>\n          props.onCrop([props.x, props.y, props.width, props.height])\n        }\n      >\n        Crop\n      </Button>\n      <Button onClick={() => props.onCropCancel()}>Cancel</Button>\n    </div>\n  </div>\n);\nconst Reactable = reactable(Demo);\n\nexport const Cropper = ({\n  onCrop,\n  onCancel,\n}: {\n  onCrop: any;\n  onCancel: any;\n}) => {\n  const [coordinate, setCoordinate] = React.useState({\n    x: 0,\n    y: 0,\n    width: 300,\n    height: 200,\n  });\n  return (\n    <Reactable\n      onCrop={onCrop}\n      onCropCancel={onCancel}\n      resizable={{\n        edges: { left: true, right: true, bottom: true, top: true },\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      draggable={{\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      onDragMove={(event: any) =>\n        setCoordinate((prev: any) => ({\n          x: prev.x + event.dx,\n          y: prev.y + event.dy,\n          width: prev.width,\n          height: prev.height,\n        }))\n      }\n      onResizeMove={(e: any) => {\n        const { width, height } = e.rect;\n        const { left, top } = e.deltaRect;\n        setCoordinate((prev) => {\n          return {\n            x: prev.x + left,\n            y: prev.y + top,\n            width,\n            height,\n          };\n        });\n      }}\n      {...coordinate}\n    />\n  );\n};\n","import React, { useEffect } from \"react\";\nimport { Frame } from \"../state\";\n\nexport const Video = ({\n  frames,\n  width,\n  height,\n  displayWidth,\n  displayHeight\n}: {\n  frames: Frame[];\n  width: number;\n  height: number;\n  displayWidth: number;\n  displayHeight: number;\n}) => {\n  const canvasRef = React.useRef(null);\n\n  const play = () => {\n    let frameIndex = 0;\n    let timeStarted = Date.now();\n    const canvas = canvasRef.current;\n    const ctx = (canvas! as HTMLCanvasElement).getContext(\"2d\");\n\n    const draw = () => {\n      const timeElapsed = Date.now() - timeStarted;\n\n      if (timeElapsed >= frames[frameIndex].timestamp) {\n        ctx?.putImageData(frames[frameIndex].imageData, 0, 0);\n        frameIndex += 1;\n\n        if (frameIndex >= frames.length) {\n          frameIndex = 0;\n          timeStarted = Date.now();\n        }\n      }\n\n      requestAnimationFrame(draw);\n    };\n\n    requestAnimationFrame(draw);\n  };\n\n  useEffect(() => {\n    play();\n  }, [canvasRef, frames]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      style={{\n        maxHeight: \"100%\",\n        height: displayHeight,\n        maxWidth: \"100%\",\n        width: displayWidth,\n        margin: \"auto\"\n      }}\n    />\n  );\n};\n","export interface State {\n  chunks: any[];\n  chunksUrl: string;\n  isRecording: boolean;\n  isConverting: boolean;\n  screenDimensions: number[] | null;\n  png: any | null;\n  gif: any | null;\n  gifWidth: number;\n  isCropping: boolean;\n  cropDimensions: number[] | null;\n  progress: number;\n  hasData: boolean;\n}\n\ninterface StartRecording {\n  type: \"startRecording\";\n}\n\ninterface RecordChunk {\n  type: \"recordChunk\";\n  chunk: any;\n}\n\ninterface StopRecording {\n  type: \"stopRecording\";\n  captureStream: any;\n}\n\ninterface StartExport {\n  type: \"startExport\";\n}\n\ninterface EndExport {\n  type: \"endExport\";\n  png?: any;\n  gif?: any;\n}\n\ninterface SetGifWidth {\n  type: \"setGifWidth\";\n  width: number;\n}\n\ninterface StartCropping {\n  type: \"startCropping\";\n}\n\ninterface EndCropping {\n  type: \"endCropping\";\n  dimensions?: number[];\n}\n\ninterface SetProgress {\n  type: \"setProgress\";\n  progress: number;\n}\n\nexport type Action =\n  | StartRecording\n  | RecordChunk\n  | StopRecording\n  | StartExport\n  | EndExport\n  | SetGifWidth\n  | StartCropping\n  | EndCropping\n  | SetProgress;\n\nexport const initialState: State = {\n  chunks: [],\n  chunksUrl: \"\",\n  isRecording: false,\n  isConverting: false,\n  screenDimensions: null,\n  png: null,\n  gif: null,\n  gifWidth: 1024,\n  isCropping: false,\n  cropDimensions: null,\n  progress: 0,\n  hasData: false\n};\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"startRecording\":\n      return {\n        ...state,\n        isRecording: true,\n        hasData: true\n      };\n\n    case \"recordChunk\":\n      return {\n        ...state,\n        chunks: [...state.chunks, action.chunk],\n      };\n    case \"stopRecording\":\n      return {\n        ...state,\n        isRecording: false,\n        chunksUrl: URL.createObjectURL(state.chunks[0]),\n        screenDimensions: [\n          action.captureStream.getVideoTracks()[0].getSettings().width,\n          action.captureStream.getVideoTracks()[0].getSettings().height,\n        ],\n      };\n    case \"startExport\":\n      return {\n        ...state,\n        isConverting: true,\n      };\n    case \"endExport\":\n      return {\n        ...state,\n        isConverting: false,\n        progress: 0,\n        png: action.png ? action.png : state.png,\n        gif: action.gif ? action.gif : state.gif,\n      };\n\n    case \"setGifWidth\":\n      return {\n        ...state,\n        gifWidth: action.width,\n      };\n\n    case \"startCropping\":\n      return {\n        ...state,\n        isCropping: true,\n      };\n\n    case \"endCropping\":\n      return {\n        ...state,\n        isCropping: false,\n        cropDimensions: action.dimensions\n          ? action.dimensions\n          : state.cropDimensions,\n      };\n\n      case \"setProgress\":\n        return {\n          ...state,\n          progress: action.progress,\n        };\n  }\n\n  return state;\n};\n\nexport interface Frame {\n  timestamp: number;\n  imageData: ImageData;\n}\n","import { Frame } from \"./state\";\n\nimport Worker from \"workerize-loader!./exportGifWorker\"; // eslint-disable-line import/no-webpack-loader-syntax\nimport GifEncoder from \"gif-encoder\";\nimport UPNG from \"upng-js\";\n\ninterface Exporter {\n  start(): void;\n  addFrame(data: Uint8ClampedArray, delay: number): void;\n  finish(): void;\n}\n\nexport class GIFExporter implements Exporter {\n  encoder: typeof GifEncoder;\n\n  constructor(width: number, height: number) {\n    this.encoder = new GifEncoder(width, height, {\n      highWaterMark: 50000000,\n    });\n  }\n\n  start(): void {\n    this.encoder.writeHeader();\n  }\n\n  addFrame(data: Uint8ClampedArray, delay: number) {\n    this.encoder.addFrame(data);\n  }\n\n  finish(): string {\n    this.encoder.finish();\n\n    return btoa(\n      this.encoder\n        .read()\n        .reduce((data: any, byte: any) => data + String.fromCharCode(byte), \"\")\n    );\n  }\n}\n\nexport class PNGExporter implements Exporter {\n  width: number;\n  height: number;\n  frames: Uint8ClampedArray[];\n  dels: number[];\n\n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n    this.frames = [];\n    this.dels = [];\n  }\n\n  start(): void {\n  }\n\n  addFrame(data: Uint8ClampedArray, del: number): void {\n    this.frames.push(data);\n    this.dels.push(del);\n  }\n  finish(): void {\n    return UPNG.encode(this.frames, this.width, this.height, 255, this.dels);\n  }\n}\n\nexport const exportImage = (\n  frames: Frame[],\n  screenWidth: number,\n  screenHeight: number,\n  x: number,\n  y: number,\n  sourceWidth: number,\n  sourceHeight: number,\n  targetWidth: number,\n  targetHeight: number,\n  onImageProgress: any,\n  onImageComplete: any,\n  exporter: Exporter\n) => {\n  const buffer = document.createElement(\"canvas\");\n  buffer.width = screenWidth;\n  buffer.height = screenHeight;\n  const bufferContext = buffer.getContext(\"2d\");\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = targetWidth;\n  canvas.height = targetHeight;\n  const canvasContext = canvas.getContext(\"2d\");\n\n  let frameIndex = 0;\n  exporter.start();\n\n  const render = () => {\n    const frame = frames[frameIndex];\n\n    onImageProgress((1.0 * frameIndex) / frames.length);\n\n    bufferContext?.putImageData(frame.imageData, 0, 0);\n\n    canvasContext?.drawImage(buffer, x, y, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);\n\n    const scaledFrame = canvasContext?.getImageData(\n      0,\n      0,\n      targetWidth,\n      targetHeight\n    )!;\n\n    const lastFrameTimestamp = frameIndex >= 1 ? frames[frameIndex - 1].timestamp : 0;\n\n    exporter.addFrame(scaledFrame.data, frame.timestamp - lastFrameTimestamp);\n    frameIndex++;\n\n    if (frameIndex < frames.length) {\n      setTimeout(render, 10);\n    } else {\n      const base64 = exporter.finish();\n      onImageComplete(base64);\n    }\n  };\n\n  setTimeout(render, 10);\n};\n","import React, { useState, useEffect, useRef, useReducer } from \"react\";\nimport \"./App.css\";\nimport { Button, NonIdealState } from \"@blueprintjs/core\";\nimport { Toolbar } from \"./components/Toolbar\";\nimport { useContainerDimensions } from \"./utils/useContainerDimensions\";\nimport { Cropper } from \"./components/Cropper\";\nimport { Video } from \"./components/Video\";\nimport { reducer, initialState, Frame } from \"./state\";\nimport { exportImage, PNGExporter, GIFExporter } from \"./export\";\n\nasync function captureDisplay(\n  displayMediaOptions: any\n): Promise<MediaStream | null> {\n  let captureStream = null;\n\n  try {\n    captureStream = await navigator.mediaDevices.getDisplayMedia(\n      displayMediaOptions\n    );\n  } catch (err) {\n    console.error(\"Error: \" + err);\n    return null;\n  }\n  return captureStream;\n}\n\nconst displayMediaOptions = {\n  video: {\n    cursor: \"always\",\n  },\n  audio: false,\n};\n\nconst App = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [mediaRecorder, setMediaRecorder] = useState<any>(null);\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [stopTime, setStopTime] = useState<number | null>(null);\n  const [currentTime, setCurrentTime] = useState<number>(Date.now());\n\n  const frames = useRef<Frame[]>([]);\n  const frameTimer = useRef<NodeJS.Timeout | null>(null);\n\n  React.useEffect(() => {\n    if (!state.hasData) return;\n    const handleBeforeUnload = (event: BeforeUnloadEvent) => {\n        return \"You haven't saved your recording. Are you sure you want to leave?\";\n    };\n    window.onbeforeunload = handleBeforeUnload;\n    return () => {\n      window.onbeforeunload = null;\n    }\n  }, [state]);\n\n  const startCapture = async () => {\n    const captureStream = await captureDisplay(displayMediaOptions);\n\n    const video = document.createElement(\"video\");\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n\n    if (!captureStream) {\n      return;\n    }\n\n    video.srcObject = captureStream;\n    let captureStartTime: number | null = null;\n\n    video.onloadeddata = () => {\n      frameTimer.current = setInterval(() => {\n        if (!captureStartTime) {\n          captureStartTime = Date.now();\n          canvas.width = video.videoWidth;\n          canvas.height = video.videoHeight;\n        }\n\n        console.log(video.videoWidth);\n        console.log(video.videoHeight);\n\n        context?.drawImage(video, 0, 0);\n\n        frames.current.push({\n          timestamp: Date.now() - captureStartTime,\n          imageData: context?.getImageData(\n            0,\n            0,\n            video.videoWidth,\n            video.videoHeight\n          )!,\n        });\n      }, 100);\n    };\n    video.play();\n\n    const _mediaRecorder = new MediaRecorder(captureStream);\n    dispatch({ type: \"startRecording\" });\n\n    _mediaRecorder.ondataavailable = (e: any) =>\n      dispatch({ type: \"recordChunk\", chunk: e.data });\n\n    _mediaRecorder.onstop = () => {\n      dispatch({ type: \"stopRecording\", captureStream });\n    };\n\n    _mediaRecorder.start();\n    setStartTime(Date.now());\n    setMediaRecorder(_mediaRecorder);\n  };\n\n  const stopCapture = async () => {\n    mediaRecorder.stop();\n    setStopTime(Date.now());\n\n    console.log(frames.current);\n    clearInterval(frameTimer.current!);\n  };\n\n  const videoRef = useRef();\n  const { width, height } = useContainerDimensions(videoRef);\n  const screenWidth = state.screenDimensions?.[0];\n  const screenHeight = state.screenDimensions?.[1];\n\n  const browserAspectRatio = width / height;\n  const videoAspectRatio = screenWidth! / screenHeight!;\n\n  let videoLeft = 0,\n    videoTop = 0,\n    videoWidth = width,\n    videoHeight = height;\n\n  if (videoAspectRatio > browserAspectRatio) {\n    const scale = width / screenWidth!;\n    const scaledHeight = scale * screenHeight!;\n\n    videoTop = 0.5 * (height - scaledHeight);\n    videoHeight = scaledHeight;\n  } else if (browserAspectRatio > videoAspectRatio) {\n    const scale = height / screenHeight!;\n    const scaledWidth = scale * screenWidth!;\n\n    videoLeft = 0.5 * (width - scaledWidth);\n    videoWidth = scaledWidth;\n  }\n\n  const onExport = (type: \"gif\" | \"png\") => {\n    dispatch({ type: \"startExport\" });\n    console.log(width, height);\n\n    const scaleFactorX = (1.0 * screenWidth!) / videoWidth;\n    const scaleFactorY = (1.0 * screenHeight!) / videoHeight;\n    const cropDimensions = state.cropDimensions;\n\n    const x = cropDimensions ? Math.round(cropDimensions[0] * scaleFactorX) : 0;\n    const y = cropDimensions ? Math.round(cropDimensions[1] * scaleFactorY) : 0;\n    const sourceWidth = cropDimensions\n      ? Math.round(cropDimensions[2] * scaleFactorX)\n      : screenWidth!;\n    const sourceHeight = cropDimensions\n      ? Math.round(cropDimensions[3] * scaleFactorY)\n      : screenHeight!;\n    const targetWidth = cropDimensions\n      ? Math.round(cropDimensions[2] * scaleFactorX)\n      : state.gifWidth;\n    const targetHeight = cropDimensions\n      ? Math.round(cropDimensions[3] * scaleFactorY)\n      : (screenHeight! * state.gifWidth) / screenWidth!;\n\n    exportImage(\n      frames.current,\n      screenWidth!,\n      screenHeight!,\n      x,\n      y,\n      sourceWidth,\n      sourceHeight,\n      targetWidth,\n      targetHeight,\n      (progress: number) => dispatch({ type: \"setProgress\", progress }),\n      (png: any) => dispatch({ type: \"endExport\", [type]: png }),\n      type == \"gif\"\n        ? new GIFExporter(targetWidth, targetHeight)\n        : new PNGExporter(targetWidth, targetHeight)\n    );\n  };\n\n  const onCrop = (dimensions: number[]) =>\n    dispatch({\n      type: \"endCropping\",\n      dimensions,\n    });\n\n  const onCropCancel = () =>\n    dispatch({\n      type: \"endCropping\",\n    });\n\n  useEffect(() => {\n    setTimeout(() => setCurrentTime(Date.now()), 1000);\n  }, [currentTime]);\n\n  const durationSecs =\n    ((stopTime ? stopTime : currentTime) -\n      (startTime ? startTime : currentTime)) /\n    1000.0;\n\n  return (\n    <div className=\"App\">\n      <main className=\"bp3-dark\">\n        <Toolbar\n          state={state}\n          dispatch={dispatch}\n          durationSecs={durationSecs}\n          onExport={onExport}\n          startCapture={startCapture}\n          stopCapture={stopCapture}\n        />\n        <div\n          style={{\n            height: \"calc(100vh - 50px)\",\n            maxHeight: \"calc(100vh - 50px)\",\n            width: \"100vw\",\n            maxWidth: \"100vw\",\n            padding: \"1rem\",\n            backgroundColor: \"#293742\",\n          }}\n        >\n          <div\n            style={{\n              width: \"100%\",\n              maxWidth: \"100%\",\n              height: \"100%\",\n              maxHeight: \"100%\",\n              position: \"relative\",\n              display: \"flex\",\n            }}\n            ref={videoRef as any}\n          >\n            <div\n              style={{\n                position: \"absolute\",\n                left: videoLeft,\n                top: videoTop,\n                width: videoWidth,\n                height: videoHeight,\n                pointerEvents: \"none\",\n              }}\n            >\n              {state.isCropping && (\n                <Cropper onCrop={onCrop} onCancel={onCropCancel} />\n              )}\n            </div>\n            {state.chunksUrl ? (\n              <Video\n                frames={frames.current}\n                width={screenWidth!}\n                height={screenHeight!}\n                displayWidth={videoWidth}\n                displayHeight={videoHeight}\n              />\n            ) : (\n              <NonIdealState\n                title={\n                  <>\n                    <p>\n                      screencatcher lets you record your desktop to an animated\n                      GIF or PNG.\n                    </p>\n                  </>\n                }\n                description={\n                  <>\n                    <p>\n                      It works entirely from your browser so doesn't require any\n                      other applications to be installed and doesn't share data\n                      with the outside world.\n                    </p>\n                  </>\n                }\n                icon=\"mobile-video\"\n                action={\n                  !state.isRecording ? (\n                    <Button onClick={startCapture} icon=\"record\">\n                      Click here to start recording\n                    </Button>\n                  ) : undefined\n                }\n              ></NonIdealState>\n            )}\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import { useEffect, useState } from \"react\";\n\nexport const useContainerDimensions = (myRef: any) => {\n  const getDimensions = () => ({\n    width: myRef.current.offsetWidth,\n    height: myRef.current.offsetHeight,\n  });\n\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setDimensions(getDimensions());\n    };\n\n    if (myRef.current) {\n      setDimensions(getDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [myRef]);\n\n  return dimensions;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
{"version":3,"sources":["export/exportPng.ts","App.tsx","export/exportGif.ts","serviceWorker.ts","index.tsx"],"names":["exportPng","video","x","y","width","height","targetWidth","targetHeight","callback","canvas","document","createElement","context","getContext","startTime","Date","now","lastTime","frames","dels","console","log","play","onloadeddata","capture","timeSinceLastFrame","drawImage","imageData","getImageData","push","data","paused","requestAnimationFrame","UPNG","encode","captureDisplay","displayMediaOptions","a","captureStream","navigator","mediaDevices","getDisplayMedia","error","cursor","audio","Video","chunksUrl","autoPlay","controls","style","maxHeight","maxWidth","src","undefined","Reactable","reactable","props","ref","getRef","position","left","top","touchAction","borderWidth","borderColor","borderStyle","pointerEvents","onClick","onCrop","onCropCancel","ResizeDemo","onCancel","React","useState","coordinate","setCoordinate","resizable","edges","right","bottom","modifiers","interact","restrictRect","restriction","draggable","onDragMove","event","prev","dx","dy","onResizeMove","e","rect","deltaRect","Toolbar","recording","converting","startCapture","stopCapture","setGifWidth","gifWidth","setCropping","durationSecs","onExportGif","onExportPng","gif","png","progress","base64","btoa","Uint8Array","reduce","byte","String","fromCharCode","disabled","icon","align","Alignment","RIGHT","minimal","content","text","map","download","href","target","value","numeral","format","App","mediaRecorder","setMediaRecorder","chunks","setChunks","setChunksUrl","setRecording","setConverting","setStartTime","stopTime","setStopTime","currentTime","setCurrentTime","screenWidth","setScreenWidth","screenHeight","setScreenHeight","setGif","setProgress","setPng","cropping","cropDimensions","setCropDimensions","_mediaRecorder","MediaRecorder","ondataavailable","existing","onstop","URL","createObjectURL","getVideoTracks","getSettings","start","stop","videoRef","useRef","myRef","getDimensions","current","offsetWidth","offsetHeight","dimensions","setDimensions","useEffect","handleResize","window","addEventListener","removeEventListener","useContainerDimensions","browserAspectRatio","videoAspectRatio","videoLeft","videoTop","videoWidth","videoHeight","scaledHeight","scaledWidth","setTimeout","className","onImageComplete","onImageProgress","gifHeight","durationMillis","numFrames","Math","trunc","gifshot","createGIF","interval","frameDuration","progressCallback","obj","image","exportGif","img","vid","scaleFactorX","scaleFactorY","round","padding","backgroundColor","title","description","action","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.8bd3a34b.chunk.js","sourcesContent":["import UPNG from \"upng-js\";\n\nexport const exportPng = (\n  video: HTMLVideoElement,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  targetWidth: number,\n  targetHeight: number,\n  callback: any\n) => {\n  const interval = 100;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = targetWidth;\n  canvas.height = targetHeight;\n  const context = canvas.getContext(\"2d\");\n\n  let startTime = Date.now();\n  let lastTime = startTime;\n\n  let frames: any[] = [];\n  let dels: number[] = [];\n\n  console.log(x);\n  console.log(y);\n  console.log(width);\n  console.log(height);\n\n  console.log(targetWidth);\n  console.log(targetHeight);\n\n  const capture = () => {\n    const timeSinceLastFrame = Date.now() - lastTime;\n    console.log(Date.now() - startTime);\n    if (timeSinceLastFrame > interval) {\n      context?.drawImage(video, x, y, width, height, 0, 0, targetWidth, targetHeight);\n      const imageData = context?.getImageData(0, 0, targetWidth, targetHeight);\n      // console.log(canvas.toDataURL('image/png'));\n      lastTime = Date.now();\n\n      frames.push(imageData?.data);\n      dels.push(timeSinceLastFrame);\n    }\n\n    if (!video.paused && Date.now() - startTime < 30000) {\n      requestAnimationFrame(capture);\n    } else {\n      callback(UPNG.encode(frames, targetWidth, targetHeight, 255, dels));\n    }\n  };\n\n  video.play();\n  video.onloadeddata = () => {\n    startTime = Date.now();\n    capture();\n  };\n};","import React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport {\n  Button,\n  ProgressBar,\n  Navbar,\n  NavbarGroup,\n  NavbarHeading,\n  Alignment,\n  NavbarDivider,\n  AnchorButton,\n  NonIdealState,\n  Slider,\n  Popover,\n  Position,\n  Menu,\n  MenuItem,\n  MenuDivider,\n} from \"@blueprintjs/core\";\nimport numeral from \"numeral\";\nimport { exportPng } from \"./export/exportPng\";\nimport { exportGif } from \"./export/exportGif\";\nimport reactable from \"reactablejs\";\nimport interact from \"interactjs\";\n\nasync function captureDisplay(displayMediaOptions: any) {\n  let captureStream = null;\n\n  try {\n    captureStream = await (navigator.mediaDevices as any).getDisplayMedia(\n      displayMediaOptions\n    );\n  } catch (err) {\n    console.error(\"Error: \" + err);\n  }\n  return captureStream;\n}\n\ndeclare var MediaRecorder: any;\n\nconst displayMediaOptions = {\n  video: {\n    cursor: \"always\",\n  },\n  audio: false,\n};\n\nconst Video = ({ chunksUrl }: { chunksUrl: any }) => {\n  return (\n    <video\n      autoPlay\n      controls\n      style={{\n        maxHeight: \"100%\",\n        height: \"100%\",\n        maxWidth: \"100%\",\n        width: \"100%\",\n      }}\n      src={chunksUrl ? chunksUrl : undefined}\n    />\n  );\n};\n\nconst Demo = (props: any) => (\n  <div\n    ref={props.getRef}\n    style={{\n      position: \"absolute\",\n      left: props.x,\n      top: props.y,\n      width: props.width,\n      height: props.height,\n      touchAction: \"none\",\n      borderWidth: 5,\n      borderColor: \"red\",\n      borderStyle: \"solid\",\n      pointerEvents: \"all\",\n    }}\n  >\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      {props.x},{props.y},{props.width},{props.height}{\" \"}\n      <Button\n        onClick={() =>\n          props.onCrop([props.x, props.y, props.width, props.height])\n        }\n      >\n        Crop\n      </Button>\n      <Button onClick={() => props.onCropCancel()}>Cancel</Button>\n    </div>\n  </div>\n);\nconst Reactable = reactable(Demo);\n\nconst useContainerDimensions = (myRef: any) => {\n  const getDimensions = () => ({\n    width: myRef.current.offsetWidth,\n    height: myRef.current.offsetHeight,\n  });\n\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setDimensions(getDimensions());\n    };\n\n    if (myRef.current) {\n      setDimensions(getDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [myRef]);\n\n  return dimensions;\n};\n\nconst ResizeDemo = ({ onCrop, onCancel }: { onCrop: any; onCancel: any; }) => {\n  const [coordinate, setCoordinate] = React.useState({\n    x: 0,\n    y: 0,\n    width: 300,\n    height: 200,\n  });\n  return (\n    <Reactable\n      onCrop={onCrop}\n      onCropCancel={onCancel}\n      resizable={{\n        edges: { left: true, right: true, bottom: true, top: true },\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      draggable={{\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      onDragMove={(event: any) =>\n        setCoordinate((prev: any) => ({\n          x: prev.x + event.dx,\n          y: prev.y + event.dy,\n          width: prev.width,\n          height: prev.height,\n        }))\n      }\n      onResizeMove={(e: any) => {\n        const { width, height } = e.rect;\n        const { left, top } = e.deltaRect;\n        setCoordinate((prev) => {\n          return {\n            x: prev.x + left,\n            y: prev.y + top,\n            width,\n            height,\n          };\n        });\n      }}\n      {...coordinate}\n    />\n  );\n};\n\nconst Toolbar = ({\n  recording,\n  converting,\n  startCapture,\n  stopCapture,\n  setGifWidth,\n  gifWidth,\n  setCropping,\n  durationSecs,\n  onExportGif,\n  onExportPng,\n  gif,\n  png,\n  progress,\n}: {\n  recording: boolean;\n  converting: boolean;\n  startCapture: any;\n  stopCapture: any;\n  setGifWidth: any;\n  gifWidth: number;\n  setCropping: any;\n  durationSecs: number;\n  onExportGif: any;\n  onExportPng: any;\n  gif: any;\n  png: any;\n  progress: number;\n}) => {\n  const base64 = btoa(\n    new Uint8Array(png).reduce(\n      (data, byte) => data + String.fromCharCode(byte),\n      \"\"\n    )\n  );\n\n  const imageWidths = [256, 512, 1024, 2048];\n\n  return (\n    <Navbar>\n      <NavbarGroup>\n        <NavbarHeading>\n          <h3>screen2gif</h3>\n        </NavbarHeading>\n        <Button disabled={recording} onClick={startCapture} icon=\"record\">\n          Record\n        </Button>\n        <Button disabled={!recording} onClick={stopCapture} icon=\"stop\">\n          Stop\n        </Button>\n      </NavbarGroup>\n\n      <NavbarGroup align={Alignment.RIGHT}>\n        <Button icon=\"zoom-to-fit\" onClick={() => setCropping(true)}>\n          Crop (PNG Only)\n        </Button>\n        <NavbarDivider />\n        <Popover\n          minimal\n          content={\n            <Menu>\n              <MenuItem\n                text=\"Export to PNG\"\n                disabled={converting}\n                onClick={onExportPng}\n              />\n              <MenuItem\n                text=\"Export to GIF\"\n                disabled={converting}\n                onClick={onExportGif}\n              />\n              <MenuDivider />\n\n              <MenuItem text=\"Image Width\">\n                {imageWidths.map((width: number) => (\n                  <MenuItem\n                    text={`${width}`}\n                    icon={gifWidth === width ? \"tick\" : null}\n                    onClick={() => setGifWidth(width)}\n                  />\n                ))}\n              </MenuItem>\n            </Menu>\n          }\n        >\n          <Button icon=\"export\" text=\"Export...\" />\n        </Popover>\n        {(png || gif) && (\n          <Popover\n            minimal\n            content={\n              <Menu>\n                <MenuItem\n                  text=\"Download PNG\"\n                  download=\"screen2gif.png\"\n                  href={`data:image/png;base64,${base64}`}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!png}\n                />\n                <MenuItem\n                  text=\"Download GIF\"\n                  download=\"screen2gif.gif\"\n                  href={gif}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!gif}\n                />\n              </Menu>\n            }\n          >\n            <Button icon=\"download\" text=\"Download...\" />\n          </Popover>\n        )}\n        {converting && (\n          <>\n            <NavbarDivider />\n            <div style={{ width: \"10rem\" }}>\n              <ProgressBar value={progress} />\n            </div>\n          </>\n        )}\n        <NavbarDivider />\n        Duration: {numeral(durationSecs > 0 ? durationSecs : 0).format(\"0.0\")}s\n      </NavbarGroup>\n    </Navbar>\n  );\n};\n\nconst App = () => {\n  const [mediaRecorder, setMediaRecorder] = useState<any>(null);\n  const [chunks, setChunks] = useState<any[]>([]);\n  const [chunksUrl, setChunksUrl] = useState<string>(\"\");\n  const [recording, setRecording] = useState<boolean>(false);\n  const [converting, setConverting] = useState<boolean>(false);\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [stopTime, setStopTime] = useState<number | null>(null);\n  const [currentTime, setCurrentTime] = useState<number>(Date.now());\n  const [gifWidth, setGifWidth] = useState<number>(1024);\n  const [screenWidth, setScreenWidth] = useState<number | null>(null);\n  const [screenHeight, setScreenHeight] = useState<number | null>(null);\n  const [gif, setGif] = useState<any>(null);\n  const [progress, setProgress] = useState(0);\n  const [png, setPng] = useState<any>(null);\n  const [cropping, setCropping] = useState(false);\n  const [cropDimensions, setCropDimensions] = useState<null | number[]>();\n\n  const startCapture = async () => {\n    const captureStream = await captureDisplay(displayMediaOptions);\n    const _mediaRecorder = new MediaRecorder(captureStream);\n    setRecording(true);\n\n    _mediaRecorder.ondataavailable = (e: any) =>\n      setChunks((existing) => {\n        existing.push(e.data);\n        return existing;\n      });\n\n    _mediaRecorder.onstop = (e: any) => {\n      setRecording(false);\n      setChunksUrl(URL.createObjectURL(chunks[0]));\n      setScreenWidth(captureStream.getVideoTracks()[0].getSettings().width);\n      setScreenHeight(captureStream.getVideoTracks()[0].getSettings().height);\n    };\n\n    _mediaRecorder.start();\n    setStartTime(Date.now());\n    setMediaRecorder(_mediaRecorder);\n  };\n\n  const stopCapture = async () => {\n    mediaRecorder.stop();\n    setStopTime(Date.now());\n  };\n\n  const videoRef = useRef();\n  const { width, height } = useContainerDimensions(videoRef);\n\n  const browserAspectRatio = width / height;\n  const videoAspectRatio = screenWidth! / screenHeight!;\n\n  let videoLeft = 0,\n    videoTop = 0,\n    videoWidth = width,\n    videoHeight = height;\n\n  if (videoAspectRatio > browserAspectRatio) {\n    const scale = width / screenWidth!;\n    const scaledHeight = scale * screenHeight!;\n\n    videoTop = 0.5 * (height - scaledHeight);\n    videoHeight = scaledHeight;\n  } else if (browserAspectRatio > videoAspectRatio) {\n    const scale = height / screenHeight!;\n    const scaledWidth = scale * screenWidth!;\n\n    videoLeft = 0.5 * (width - scaledWidth);\n    videoWidth = scaledWidth;\n  }\n\n  console.log(videoLeft, videoTop, videoWidth, videoHeight);\n\n  const onExportPng = () => {\n    const vid = document.createElement(\"video\");\n    vid.src = chunksUrl;\n    vid.width = screenWidth!;\n    vid.height = screenHeight!;\n    setConverting(true);\n\n    console.log(cropDimensions);\n    console.log(width);\n    console.log(screenWidth);\n    console.log(height);\n    console.log(screenHeight);\n\n    const scaleFactorX = (1.0 * screenWidth!) / width;\n    const scaleFactorY = (1.0 * screenHeight!) / height;\n\n    exportPng(\n      vid,\n      cropDimensions ? Math.round(cropDimensions[0] * scaleFactorX) : 0,\n      cropDimensions ? Math.round(cropDimensions[1] * scaleFactorY) : 0,\n      cropDimensions\n        ? Math.round(cropDimensions[2] * scaleFactorX)\n        : screenWidth!,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : screenHeight!,\n      cropDimensions ? Math.round(cropDimensions[2] * scaleFactorX) : gifWidth,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : (screenHeight! * gifWidth) / screenWidth!,\n      (png: any) => {\n        setConverting(false);\n        setPng(png);\n      }\n    );\n  };\n\n  const onCrop = (dimensions: number[]) => {\n    setCropDimensions(dimensions);\n    setCropping(false);\n  };\n\n  const onCropCancel = () => {\n    setCropping(false);\n  }\n\n  useEffect(() => {\n    setTimeout(() => setCurrentTime(Date.now()), 1000);\n  }, [currentTime]);\n\n  const durationSecs =\n    ((stopTime ? stopTime : currentTime) -\n      (startTime ? startTime : currentTime)) /\n    1000.0;\n\n  const onExportGif = () => {\n    setConverting(true);\n    exportGif(\n      chunks,\n      startTime!,\n      stopTime!,\n      screenWidth!,\n      screenHeight!,\n      (img: any) => {\n        setGif(img);\n        setConverting(false);\n      },\n      setProgress,\n      gifWidth\n    );\n  };\n\n  return (\n    <div className=\"App\">\n      <main className=\"bp3-dark\">\n        <Toolbar\n          converting={converting}\n          durationSecs={durationSecs}\n          gif={gif}\n          gifWidth={gifWidth}\n          onExportGif={onExportGif}\n          onExportPng={onExportPng}\n          png={png}\n          progress={progress}\n          recording={recording}\n          setCropping={setCropping}\n          setGifWidth={setGifWidth}\n          startCapture={startCapture}\n          stopCapture={stopCapture}\n        />\n        <div\n          style={{\n            height: \"calc(100vh - 50px)\",\n            maxHeight: \"calc(100vh - 50px)\",\n            width: \"100vw\",\n            maxWidth: \"100vw\",\n            padding: \"1rem\",\n            backgroundColor: \"#293742\",\n          }}\n        >\n          <div\n            style={{\n              width: \"100%\",\n              maxWidth: \"100%\",\n              height: \"100%\",\n              maxHeight: \"100%\",\n              position: \"relative\",\n            }}\n            ref={videoRef as any}\n          >\n            <div\n              style={{\n                position: \"absolute\",\n                left: videoLeft,\n                top: videoTop,\n                width: videoWidth,\n                height: videoHeight,\n                pointerEvents: \"none\",\n              }}\n            >\n              {cropping && (\n                <ResizeDemo onCrop={onCrop} onCancel={onCropCancel} />\n              )}\n            </div>\n            {chunksUrl ? (\n              <Video chunksUrl={chunksUrl} />\n            ) : (\n              <NonIdealState\n                title=\"Nothing on tape yet\"\n                description=\"Record something\"\n                icon=\"warning-sign\"\n                action={\n                  !recording ? (\n                    <Button\n                      disabled={recording}\n                      onClick={startCapture}\n                      icon=\"record\"\n                    >\n                      Record\n                    </Button>\n                  ) : undefined\n                }\n              ></NonIdealState>\n            )}\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import gifshot from \"gifshot\";\n\nexport const exportGif = (\n  chunks: any[],\n  startTime: number,\n  stopTime: number,\n  screenWidth: number,\n  screenHeight: number,\n  onImageComplete: any,\n  onImageProgress: any,\n  gifWidth: number\n) => {\n  const scaleFactor = gifWidth / screenWidth;\n  const gifHeight = scaleFactor * screenHeight;\n  const durationMillis = 1.0 * (stopTime - startTime);\n  const framesPerSecond = 5;\n  const frameDuration = 10.0 / framesPerSecond;\n  const numFrames = Math.trunc((framesPerSecond * durationMillis) / 1000.0);\n  const interval = 1.0 / framesPerSecond;\n\n  onImageProgress(0);\n  gifshot.createGIF(\n    {\n      video: chunks,\n      gifWidth,\n      gifHeight,\n      numFrames,\n      interval,\n      frameDuration,\n      progressCallback: onImageProgress,\n    },\n    function (obj: any) {\n      if (!obj.error) {\n        var image = obj.image;\n        onImageComplete(image);\n      }\n    }\n  );\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
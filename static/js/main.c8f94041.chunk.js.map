{"version":3,"sources":["export/exportPng.ts","App.tsx","export/exportGif.ts","serviceWorker.ts","index.tsx"],"names":["exportPng","video","x","y","width","height","targetWidth","targetHeight","callback","canvas","document","createElement","context","getContext","startTime","Date","now","lastTime","frames","dels","console","log","play","onloadeddata","capture","timeSinceLastFrame","drawImage","imageData","getImageData","push","data","paused","requestAnimationFrame","UPNG","encode","captureDisplay","displayMediaOptions","a","captureStream","navigator","mediaDevices","getDisplayMedia","error","cursor","audio","Video","chunksUrl","autoPlay","controls","style","maxHeight","maxWidth","src","undefined","Reactable","reactable","props","ref","getRef","position","left","top","touchAction","borderWidth","borderColor","borderStyle","pointerEvents","onClick","onCrop","ResizeDemo","React","useState","coordinate","setCoordinate","resizable","edges","right","bottom","modifiers","interact","restrictRect","restriction","draggable","onDragMove","event","prev","dx","dy","onResizeMove","e","rect","deltaRect","App","mediaRecorder","setMediaRecorder","chunks","setChunks","setChunksUrl","recording","setRecording","converting","setConverting","setStartTime","stopTime","setStopTime","currentTime","setCurrentTime","gifWidth","setGifWidth","screenWidth","setScreenWidth","screenHeight","setScreenHeight","gif","setGif","progress","setProgress","png","setPng","cropping","setCropping","cropDimensions","setCropDimensions","startCapture","_mediaRecorder","MediaRecorder","ondataavailable","existing","onstop","URL","createObjectURL","getVideoTracks","getSettings","start","stopCapture","stop","videoRef","useRef","myRef","getDimensions","current","offsetWidth","offsetHeight","dimensions","setDimensions","useEffect","handleResize","window","addEventListener","removeEventListener","useContainerDimensions","browserAspectRatio","videoAspectRatio","videoLeft","videoTop","videoWidth","videoHeight","scaledHeight","scaledWidth","setTimeout","durationSecs","base64","btoa","Uint8Array","reduce","byte","String","fromCharCode","className","disabled","icon","paddingLeft","min","max","stepSize","labelStepSize","onChange","value","align","Alignment","RIGHT","onImageComplete","onImageProgress","gifHeight","durationMillis","numFrames","Math","trunc","gifshot","createGIF","interval","frameDuration","progressCallback","obj","image","exportGif","img","download","href","target","vid","scaleFactorX","scaleFactorY","round","numeral","format","padding","backgroundColor","title","description","action","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"0TAEaA,EAAY,SACvBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IACMC,EAASC,SAASC,cAAc,UACtCF,EAAOL,MAAQE,EACfG,EAAOJ,OAASE,EAChB,IAAMK,EAAUH,EAAOI,WAAW,MAE9BC,EAAYC,KAAKC,MACjBC,EAAWH,EAEXI,EAAgB,GAChBC,EAAiB,GAErBC,QAAQC,IAAInB,GACZkB,QAAQC,IAAIlB,GACZiB,QAAQC,IAAIjB,GACZgB,QAAQC,IAAIhB,GAEZe,QAAQC,IAAIf,GACZc,QAAQC,IAAId,GAsBZN,EAAMqB,OACNrB,EAAMsB,aAAe,WACnBT,EAAYC,KAAKC,MAtBH,SAAVQ,IACJ,IAAMC,EAAqBV,KAAKC,MAAQC,EAExC,GADAG,QAAQC,IAAIN,KAAKC,MAAQF,GACrBW,EAvBW,IAuBoB,CAC1B,OAAPb,QAAO,IAAPA,KAASc,UAAUzB,EAAOC,EAAGC,EAAGC,EAAOC,EAAQ,EAAG,EAAGC,EAAaC,GAClE,IAAMoB,EAAS,OAAGf,QAAH,IAAGA,OAAH,EAAGA,EAASgB,aAAa,EAAG,EAAGtB,EAAaC,GAE3DU,EAAWF,KAAKC,MAEhBE,EAAOW,KAAP,OAAYF,QAAZ,IAAYA,OAAZ,EAAYA,EAAWG,MACvBX,EAAKU,KAAKJ,IAGPxB,EAAM8B,QAAUhB,KAAKC,MAAQF,EAAY,IAC5CkB,sBAAsBR,GAEtBhB,EAASyB,IAAKC,OAAOhB,EAAQZ,EAAaC,EAAc,IAAKY,IAO/DK,K,mDCnCWW,E,8EAAf,WAA8BC,GAA9B,eAAAC,EAAA,6DACMC,EAAgB,KADtB,kBAI2BC,UAAUC,aAAqBC,gBACpDL,GALN,OAIIE,EAJJ,uDAQIlB,QAAQsB,MAAM,gBARlB,iCAUSJ,GAVT,0D,sBAeA,IAAMF,EAAsB,CAC1BnC,MAAO,CACL0C,OAAQ,UAEVC,OAAO,GAKHC,EAAQ,SAAC,GAAuC,IAArCC,EAAoC,EAApCA,UACf,OACE,2BACEC,UAAQ,EACRC,UAAQ,EACRC,MAAO,CACLC,UAAW,OACX7C,OAAQ,OACR8C,SAAU,OACV/C,MAAO,QAETgD,IAAKN,QAAwBO,KA2B7BC,EAAYC,aAtBL,SAACC,GAAD,OACX,yBACEC,IAAKD,EAAME,OACXT,MAAO,CACLU,SAAU,WACVC,KAAMJ,EAAMtD,EACZ2D,IAAKL,EAAMrD,EACXC,MAAOoD,EAAMpD,MACbC,OAAQmD,EAAMnD,OACdyD,YAAa,OACbC,YAAa,EACbC,YAAa,MACbC,YAAa,QACbC,cAAe,QAGjB,yBAAKjB,MAAO,CAAE7C,MAAO,OAAQC,OAAQ,SAClCmD,EAAMtD,EADT,IACasD,EAAMrD,EADnB,IACuBqD,EAAMpD,MAD7B,IACqCoD,EAAMnD,OAAQ,IACjD,kBAAC,SAAD,CAAQ8D,QAAS,kBAAMX,EAAMY,OAAO,CAACZ,EAAMtD,EAAGsD,EAAMrD,EAAGqD,EAAMpD,MAAOoD,EAAMnD,WAA1E,aAiCAgE,EAAa,SAAC,GAAiC,IAA/BD,EAA8B,EAA9BA,OAA8B,EACdE,IAAMC,SAAS,CAAErE,EAAG,EAAGC,EAAG,EAAGC,MAAO,IAAKC,OAAQ,MADnC,mBAC3CmE,EAD2C,KAC/BC,EAD+B,KAElD,OACE,kBAACnB,EAAD,eACEc,OAAQA,EACRM,UAAW,CACTC,MAAO,CAAEf,MAAM,EAAMgB,OAAO,EAAMC,QAAQ,EAAMhB,KAAK,GACrDiB,UAAW,CACTC,IAASD,UAAUE,aAAa,CAC9BC,YAAa,aAInBC,UAAW,CACTJ,UAAW,CACTC,IAASD,UAAUE,aAAa,CAC9BC,YAAa,aAInBE,WAAY,SAACC,GAAD,OACVX,GAAc,SAACY,GAAD,MAAgB,CAC5BnF,EAAGmF,EAAKnF,EAAIkF,EAAME,GAClBnF,EAAGkF,EAAKlF,EAAIiF,EAAMG,GAClBnF,MAAOiF,EAAKjF,MACZC,OAAQgF,EAAKhF,YAGjBmF,aAAc,SAACC,GAAY,IAAD,EACEA,EAAEC,KAApBtF,EADgB,EAChBA,MAAOC,EADS,EACTA,OADS,EAEFoF,EAAEE,UAAhB/B,EAFgB,EAEhBA,KAAMC,EAFU,EAEVA,IACdY,GAAc,SAACY,GACb,MAAO,CACLnF,EAAGmF,EAAKnF,EAAI0D,EACZzD,EAAGkF,EAAKlF,EAAI0D,EACZzD,QACAC,eAIFmE,KAgSKoB,EA1RH,WAAO,IAAD,EAC0BrB,mBAAc,MADxC,mBACTsB,EADS,KACMC,EADN,OAEYvB,mBAAgB,IAF5B,mBAETwB,EAFS,KAEDC,EAFC,OAGkBzB,mBAAiB,IAHnC,mBAGTzB,EAHS,KAGEmD,EAHF,OAIkB1B,oBAAkB,GAJpC,mBAIT2B,EAJS,KAIEC,EAJF,OAKoB5B,oBAAkB,GALtC,mBAKT6B,EALS,KAKGC,EALH,OAMkB9B,mBAAwB,MAN1C,mBAMTzD,EANS,KAMEwF,EANF,OAOgB/B,mBAAwB,MAPxC,mBAOTgC,EAPS,KAOCC,EAPD,OAQsBjC,mBAAiBxD,KAAKC,OAR5C,mBAQTyF,EARS,KAQIC,EARJ,OASgBnC,mBAAiB,MATjC,mBASToC,EATS,KASCC,EATD,OAUsBrC,mBAAwB,MAV9C,mBAUTsC,EAVS,KAUIC,EAVJ,OAWwBvC,mBAAwB,MAXhD,oBAWTwC,GAXS,MAWKC,GAXL,SAYMzC,mBAAc,MAZpB,qBAYT0C,GAZS,MAYJC,GAZI,SAagB3C,mBAAS,GAbzB,qBAaT4C,GAbS,MAaCC,GAbD,SAcM7C,mBAAc,MAdpB,qBAcT8C,GAdS,MAcJC,GAdI,SAegB/C,oBAAS,GAfzB,qBAeTgD,GAfS,MAeCC,GAfD,SAgB4BjD,qBAhB5B,qBAgBTkD,GAhBS,MAgBOC,GAhBP,MAkBVC,GAAY,uCAAG,8BAAAtF,EAAA,sEACSF,EAAeC,GADxB,OACbE,EADa,OAEbsF,EAAiB,IAAIC,cAAcvF,GACzC6D,GAAa,GAEbyB,EAAeE,gBAAkB,SAACrC,GAAD,OAC/BO,GAAU,SAAC+B,GAET,OADAA,EAASlG,KAAK4D,EAAE3D,MACTiG,MAGXH,EAAeI,OAAS,SAACvC,GACvBU,GAAa,GACbF,EAAagC,IAAIC,gBAAgBnC,EAAO,KACxCe,EAAexE,EAAc6F,iBAAiB,GAAGC,cAAchI,OAC/D4G,GAAgB1E,EAAc6F,iBAAiB,GAAGC,cAAc/H,SAGlEuH,EAAeS,QACf/B,EAAavF,KAAKC,OAClB8E,EAAiB8B,GApBE,4CAAH,qDAuBZU,GAAW,uCAAG,sBAAAjG,EAAA,sDAClBwD,EAAc0C,OACd/B,EAAYzF,KAAKC,OAFC,2CAAH,qDAKXwH,GAAWC,mBA9CD,GAzEa,SAACC,GAC9B,IAAMC,EAAgB,iBAAO,CAC3BvI,MAAOsI,EAAME,QAAQC,YACrBxI,OAAQqI,EAAME,QAAQE,eAHoB,EAMRvE,mBAAS,CAAEnE,MAAO,EAAGC,OAAQ,IANrB,mBAMrC0I,EANqC,KAMzBC,EANyB,KAwB5C,OAhBAC,qBAAU,WACR,IAAMC,EAAe,WACnBF,EAAcL,MAShB,OANID,EAAME,SACRI,EAAcL,KAGhBQ,OAAOC,iBAAiB,SAAUF,GAE3B,WACLC,OAAOE,oBAAoB,SAAUH,MAEtC,CAACR,IAEGK,EAgGmBO,CAAuBd,IAAzCpI,GA/CQ,GA+CRA,MAAOC,GA/CC,GA+CDA,OAETkJ,GAAqBnJ,GAAQC,GAC7BmJ,GAAmB3C,EAAeE,GAEpC0C,GAAY,EAAGC,GAAW,EAAGC,GAAavJ,GAAOwJ,GAAcvJ,GAEnE,GAAImJ,GAAmBD,GAAoB,CACzC,IACMM,GADQzJ,GAAQyG,EACOE,GAE7B2C,GAAW,IAAOrJ,GAASwJ,IAC3BD,GAAcC,QACT,GAAIN,GAAqBC,GAAkB,CAChD,IACMM,GADQzJ,GAAS0G,GACKF,EAE5B4C,GAAY,IAAOrJ,GAAQ0J,IAC3BH,GAAaG,GAGf1I,QAAQC,IAAIoI,GAAWC,GAAUC,GAAYC,IA8C7CX,qBAAU,WACRc,YAAW,kBAAMrD,EAAe3F,KAAKC,SAAQ,OAC5C,CAACyF,IAEJ,IAAMuD,KACFzD,GAAsBE,IACrB3F,GAAwB2F,IAC3B,IAEIwD,GAASC,KACb,IAAIC,WAAW9C,IAAK+C,QAClB,SAACtI,EAAMuI,GAAP,OAAgBvI,EAAOwI,OAAOC,aAAaF,KAC3C,KAoBJ,OACE,yBAAKG,UAAU,OACb,0BAAMA,UAAU,YACd,kBAAC,SAAD,KACE,kBAAC,cAAD,KACE,kBAAC,gBAAD,KACE,2CAEF,kBAAC,SAAD,CAAQC,SAAUvE,EAAW/B,QAASwD,GAAc+C,KAAK,UAAzD,UAGA,kBAAC,SAAD,CAAQD,UAAWvE,EAAW/B,QAASmE,GAAaoC,KAAK,QAAzD,QAGA,kBAAC,gBAAD,MAVF,aAYE,yBAAKzH,MAAO,CAAE0H,YAAa,SACzB,kBAAC,SAAD,CACEC,IAAK,IACLC,IAAK,KACLC,SAAU,IACVC,cAAe,IACfC,SAAUpE,EACVqE,MAAOtE,MAKb,kBAAC,cAAD,CAAauE,MAAOC,YAAUC,OAC5B,kBAAC,SAAD,CAAQjH,QAAS,kBAAMqD,IAAY,KAAnC,mBACA,kBAAC,SAAD,CAAQiD,SAAUrE,EAAYjC,QA9CpB,WAClBkC,GAAc,GC9RO,SACvBN,EACAjF,EACAyF,EACAM,EACAE,EACAsE,EACAC,EACA3E,GAEA,IACM4E,EADc5E,EAAWE,EACCE,EAC1ByE,EAAiB,GAAOjF,EAAWzF,GAGnC2K,EAAYC,KAAKC,MAFC,EAEwBH,EAAkB,KAGlEF,EAAgB,GAChBM,IAAQC,UACN,CACE5L,MAAO8F,EACPY,WACA4E,YACAE,YACAK,SATa,GAUbC,cAZkB,EAalBC,iBAAkBV,IAEpB,SAAUW,GACR,IAAKA,EAAIvJ,MAAO,CACd,IAAIwJ,EAAQD,EAAIC,MAChBb,EAAgBa,OD+PpBC,CAAUpG,EACFjF,EACAyF,EACAM,EACAE,IACA,SAACqF,GACClF,GAAOkF,GACP/F,GAAc,KAEhBe,GACAT,KAkCA,gBAGCM,IACC,oCACE,kBAAC,eAAD,CACEoF,SAAS,iBACTC,KAAMrF,GACNsF,OAAO,SACP7B,KAAK,WACLD,UAAWxD,IALb,iBAWJ,kBAAC,gBAAD,MACA,kBAAC,SAAD,CAAQ9C,QA3HE,WAClB,IAAMqI,EAAM9L,SAASC,cAAc,SACnC6L,EAAIpJ,IAAMN,EACV0J,EAAIpM,MAAQyG,EACZ2F,EAAInM,OAAS0G,GACbV,GAAc,GAEdjF,QAAQC,IAAIoG,IACZrG,QAAQC,IAAIjB,IACZgB,QAAQC,IAAIwF,GACZzF,QAAQC,IAAIhB,IACZe,QAAQC,IAAI0F,IAEZ,IAAM0F,EAAe,EAAM5F,EAAezG,GACpCsM,EAAe,EAAM3F,GAAgB1G,GAE3CL,EACEwM,EACA/E,GAAiBiE,KAAKiB,MAAMlF,GAAe,GAAKgF,GAAgB,EAChEhF,GAAiBiE,KAAKiB,MAAMlF,GAAe,GAAKiF,GAAgB,EAChEjF,GACIiE,KAAKiB,MAAMlF,GAAe,GAAKgF,GAC/B5F,EACJY,GACIiE,KAAKiB,MAAMlF,GAAe,GAAKiF,GAC/B3F,GACJU,GACIiE,KAAKiB,MAAMlF,GAAe,GAAKgF,GAC/B9F,EACJc,GACIiE,KAAKiB,MAAMlF,GAAe,GAAKiF,GAC9B3F,GAAgBJ,EAAYE,GACjC,SAACQ,GACChB,GAAc,GACdiB,GAAOD,OAyF2BoD,SAAUrE,GAAxC,gBAGCiB,IACC,oCACE,kBAAC,eAAD,CACEgF,SAAS,iBACTC,KAAI,gCAA2BrC,IAC/BsC,OAAO,SACP7B,KAAK,WACLD,UAAWpD,IALb,iBAWHjB,GACC,oCACE,kBAAC,gBAAD,MACA,yBAAKnD,MAAO,CAAE7C,MAAO,UACnB,kBAAC,cAAD,CAAa6K,MAAO9D,OAI1B,kBAAC,gBAAD,MA3CF,YA4CY,IACTyF,IAAQ5C,GAAe,EAAIA,GAAe,GAAG6C,OAAO,OA7CvD,MAiDF,yBACE5J,MAAO,CACL5C,OAAQ,qBACR6C,UAAW,qBACX9C,MAAO,QACP+C,SAAU,QACV2J,QAAS,OACTC,gBAAiB,YAGnB,yBACE9J,MAAO,CACL7C,MAAO,OACP+C,SAAU,OACV9C,OAAQ,OACR6C,UAAW,OACXS,SAAU,YAEZF,IAAK+E,IAEL,yBACEvF,MAAO,CACLU,SAAU,WACVC,KAAM6F,GACN5F,IAAK6F,GACLtJ,MAAOuJ,GACPtJ,OAAQuJ,GACR1F,cAAe,SAGhBqD,IAAY,kBAAC,EAAD,CAAYnD,OAhJtB,SAAC2E,GACdrB,GAAkBqB,GAClBvB,IAAY,OAgJH1E,EACC,kBAAC,EAAD,CAAOA,UAAWA,IAElB,kBAAC,gBAAD,CACEkK,MAAM,sBACNC,YAAY,mBACZvC,KAAK,eACLwC,OACGhH,OAQG7C,EAPF,kBAAC,SAAD,CACEoH,SAAUvE,EACV/B,QAASwD,GACT+C,KAAK,UAHP,iBEzZAyC,QACW,cAA7BhE,OAAOiE,SAASC,UAEe,UAA7BlE,OAAOiE,SAASC,UAEhBlE,OAAOiE,SAASC,SAASC,MACvB,2D,cCTNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF/M,SAASgN,eAAe,SD8HpB,kBAAmBnL,WACrBA,UAAUoL,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAtL,GACLtB,QAAQsB,MAAMA,EAAMuL,c","file":"static/js/main.c8f94041.chunk.js","sourcesContent":["import UPNG from \"upng-js\";\n\nexport const exportPng = (\n  video: HTMLVideoElement,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  targetWidth: number,\n  targetHeight: number,\n  callback: any\n) => {\n  const interval = 100;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = targetWidth;\n  canvas.height = targetHeight;\n  const context = canvas.getContext(\"2d\");\n\n  let startTime = Date.now();\n  let lastTime = startTime;\n\n  let frames: any[] = [];\n  let dels: number[] = [];\n\n  console.log(x);\n  console.log(y);\n  console.log(width);\n  console.log(height);\n\n  console.log(targetWidth);\n  console.log(targetHeight);\n\n  const capture = () => {\n    const timeSinceLastFrame = Date.now() - lastTime;\n    console.log(Date.now() - startTime);\n    if (timeSinceLastFrame > interval) {\n      context?.drawImage(video, x, y, width, height, 0, 0, targetWidth, targetHeight);\n      const imageData = context?.getImageData(0, 0, targetWidth, targetHeight);\n      // console.log(canvas.toDataURL('image/png'));\n      lastTime = Date.now();\n\n      frames.push(imageData?.data);\n      dels.push(timeSinceLastFrame);\n    }\n\n    if (!video.paused && Date.now() - startTime < 30000) {\n      requestAnimationFrame(capture);\n    } else {\n      callback(UPNG.encode(frames, targetWidth, targetHeight, 255, dels));\n    }\n  };\n\n  video.play();\n  video.onloadeddata = () => {\n    startTime = Date.now();\n    capture();\n  };\n};","import React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport {\n  Button,\n  ProgressBar,\n  Navbar,\n  NavbarGroup,\n  NavbarHeading,\n  Alignment,\n  NavbarDivider,\n  AnchorButton,\n  NonIdealState,\n  Slider,\n} from \"@blueprintjs/core\";\nimport numeral from \"numeral\";\nimport { exportPng } from \"./export/exportPng\";\nimport { exportGif } from \"./export/exportGif\";\nimport reactable from \"reactablejs\";\nimport interact from \"interactjs\";\n\nasync function captureDisplay(displayMediaOptions: any) {\n  let captureStream = null;\n\n  try {\n    captureStream = await (navigator.mediaDevices as any).getDisplayMedia(\n      displayMediaOptions\n    );\n  } catch (err) {\n    console.error(\"Error: \" + err);\n  }\n  return captureStream;\n}\n\ndeclare var MediaRecorder: any;\n\nconst displayMediaOptions = {\n  video: {\n    cursor: \"always\",\n  },\n  audio: false,\n};\n\n\n\nconst Video = ({ chunksUrl }: { chunksUrl: any }) => {\n  return (\n    <video\n      autoPlay\n      controls\n      style={{\n        maxHeight: \"100%\",\n        height: \"100%\",\n        maxWidth: \"100%\",\n        width: \"100%\",\n      }}\n      src={chunksUrl ? chunksUrl : undefined}\n    />\n  );\n};\n\nconst Demo = (props: any) => (\n  <div\n    ref={props.getRef}\n    style={{\n      position: \"absolute\",\n      left: props.x,\n      top: props.y,\n      width: props.width,\n      height: props.height,\n      touchAction: \"none\",\n      borderWidth: 5,\n      borderColor: \"red\",\n      borderStyle: \"solid\",\n      pointerEvents: \"all\"\n    }}\n  >\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      {props.x},{props.y},{props.width},{props.height}{\" \"}\n      <Button onClick={() => props.onCrop([props.x, props.y, props.width, props.height])}>Crop</Button>\n    </div>\n  </div>\n);\nconst Reactable = reactable(Demo);\n\nconst useContainerDimensions = (myRef:any) => {\n  const getDimensions = () => ({\n    width: myRef.current.offsetWidth,\n    height: myRef.current.offsetHeight\n  })\n\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })\n\n  useEffect(() => {\n    const handleResize = () => {\n      setDimensions(getDimensions())\n    }\n\n    if (myRef.current) {\n      setDimensions(getDimensions())\n    }\n\n    window.addEventListener(\"resize\", handleResize)\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize)\n    }\n  }, [myRef])\n\n  return dimensions;\n};\n\nconst ResizeDemo = ({ onCrop }: { onCrop: any }) => {\n  const [coordinate, setCoordinate] = React.useState({ x: 0, y: 0, width: 300, height: 200 });\n  return (\n    <Reactable\n      onCrop={onCrop}\n      resizable={{\n        edges: { left: true, right: true, bottom: true, top: true },\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      draggable={{\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      onDragMove={(event: any) =>\n        setCoordinate((prev: any) => ({\n          x: prev.x + event.dx,\n          y: prev.y + event.dy,\n          width: prev.width,\n          height: prev.height,\n        }))\n      }\n      onResizeMove={(e: any) => {\n        const { width, height } = e.rect;\n        const { left, top } = e.deltaRect;\n        setCoordinate((prev) => {\n          return {\n            x: prev.x + left,\n            y: prev.y + top,\n            width,\n            height,\n          };\n        });\n      }}\n      {...coordinate}\n    />\n  );\n};\n\n\nconst App = () => {\n  const [mediaRecorder, setMediaRecorder] = useState<any>(null);\n  const [chunks, setChunks] = useState<any[]>([]);\n  const [chunksUrl, setChunksUrl] = useState<string>(\"\");\n  const [recording, setRecording] = useState<boolean>(false);\n  const [converting, setConverting] = useState<boolean>(false);\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [stopTime, setStopTime] = useState<number | null>(null);\n  const [currentTime, setCurrentTime] = useState<number>(Date.now());\n  const [gifWidth, setGifWidth] = useState<number>(1024);\n  const [screenWidth, setScreenWidth] = useState<number | null>(null);\n  const [screenHeight, setScreenHeight] = useState<number | null>(null);\n  const [gif, setGif] = useState<any>(null);\n  const [progress, setProgress] = useState(0);\n  const [png, setPng] = useState<any>(null);\n  const [cropping, setCropping] = useState(false);\n  const [cropDimensions, setCropDimensions] = useState<null | number[]>();\n\n  const startCapture = async () => {\n    const captureStream = await captureDisplay(displayMediaOptions);\n    const _mediaRecorder = new MediaRecorder(captureStream);\n    setRecording(true);\n\n    _mediaRecorder.ondataavailable = (e: any) =>\n      setChunks((existing) => {\n        existing.push(e.data);\n        return existing;\n      });\n\n    _mediaRecorder.onstop = (e: any) => {\n      setRecording(false);\n      setChunksUrl(URL.createObjectURL(chunks[0]));\n      setScreenWidth(captureStream.getVideoTracks()[0].getSettings().width);\n      setScreenHeight(captureStream.getVideoTracks()[0].getSettings().height);\n    };\n\n    _mediaRecorder.start();\n    setStartTime(Date.now());\n    setMediaRecorder(_mediaRecorder);\n  };\n\n  const stopCapture = async () => {\n    mediaRecorder.stop();\n    setStopTime(Date.now());\n  };\n\n  const videoRef = useRef();\n  const { width, height } = useContainerDimensions(videoRef);\n\n  const browserAspectRatio = width / height;\n  const videoAspectRatio = screenWidth! / screenHeight!;\n\n  let videoLeft = 0, videoTop = 0, videoWidth = width, videoHeight = height;\n\n  if (videoAspectRatio > browserAspectRatio) {\n    const scale = width / screenWidth!;\n    const scaledHeight = scale * screenHeight!;\n\n    videoTop = 0.5 * (height - scaledHeight);\n    videoHeight = scaledHeight;\n  } else if (browserAspectRatio > videoAspectRatio) {\n    const scale = height / screenHeight!;\n    const scaledWidth = scale * screenWidth!;\n\n    videoLeft = 0.5 * (width - scaledWidth);\n    videoWidth = scaledWidth;\n  }\n\n  console.log(videoLeft, videoTop, videoWidth, videoHeight);\n\n  const onExportPng = () => {\n    const vid = document.createElement(\"video\");\n    vid.src = chunksUrl;\n    vid.width = screenWidth!;\n    vid.height = screenHeight!;\n    setConverting(true);\n\n    console.log(cropDimensions);\n    console.log(width);\n    console.log(screenWidth);\n    console.log(height);\n    console.log(screenHeight);\n\n    const scaleFactorX = 1.0 * screenWidth! / width;\n    const scaleFactorY = 1.0 * screenHeight! / height;\n\n    exportPng(\n      vid,\n      cropDimensions ? Math.round(cropDimensions[0] * scaleFactorX) : 0,\n      cropDimensions ? Math.round(cropDimensions[1] * scaleFactorY) : 0,\n      cropDimensions\n        ? Math.round(cropDimensions[2] * scaleFactorX)\n        : screenWidth!,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : screenHeight!,\n      cropDimensions\n        ? Math.round(cropDimensions[2] * scaleFactorX)\n        : gifWidth,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : (screenHeight! * gifWidth) / screenWidth!,\n      (png: any) => {\n        setConverting(false);\n        setPng(png);\n      }\n    );\n  };\n\n  const onCrop = (dimensions: number[]) => {\n    setCropDimensions(dimensions);\n    setCropping(false);\n  }\n\n  useEffect(() => {\n    setTimeout(() => setCurrentTime(Date.now()), 1000);\n  }, [currentTime]);\n\n  const durationSecs =\n    ((stopTime ? stopTime : currentTime) -\n      (startTime ? startTime : currentTime)) /\n    1000.0;\n\n  const base64 = btoa(\n    new Uint8Array(png).reduce(\n      (data, byte) => data + String.fromCharCode(byte),\n      \"\"\n    )\n  );\n\n  const onExportGif = () => {\n    setConverting(true);\n    exportGif(chunks,\n            startTime!,\n            stopTime!,\n            screenWidth!,\n            screenHeight!,\n            (img: any) => {\n              setGif(img);\n              setConverting(false);\n            },\n            setProgress,\n            gifWidth\n    );\n  }\n\n  return (\n    <div className=\"App\">\n      <main className=\"bp3-dark\">\n        <Navbar>\n          <NavbarGroup>\n            <NavbarHeading>\n              <h3>screen2gif</h3>\n            </NavbarHeading>\n            <Button disabled={recording} onClick={startCapture} icon=\"record\">\n              Record\n            </Button>\n            <Button disabled={!recording} onClick={stopCapture} icon=\"stop\">\n              Stop\n            </Button>\n            <NavbarDivider />\n            Width (px)\n            <div style={{ paddingLeft: \"1rem\" }}>\n              <Slider\n                min={256}\n                max={2048}\n                stepSize={256}\n                labelStepSize={512}\n                onChange={setGifWidth}\n                value={gifWidth}\n              />\n            </div>\n          </NavbarGroup>\n\n          <NavbarGroup align={Alignment.RIGHT}>\n            <Button onClick={() => setCropping(true)}>Crop (PNG Only)</Button>\n            <Button disabled={converting} onClick={onExportGif}>\n              Export (GIF)\n            </Button>\n            {gif && (\n              <>\n                <AnchorButton\n                  download=\"screen2gif.gif\"\n                  href={gif}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!gif}\n                >\n                  Download GIF\n                </AnchorButton>\n              </>\n            )}\n            <NavbarDivider />\n            <Button onClick={onExportPng} disabled={converting}>\n              Export (PNG)\n            </Button>\n            {png && (\n              <>\n                <AnchorButton\n                  download=\"screen2gif.png\"\n                  href={`data:image/png;base64,${base64}`}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!png}\n                >\n                  Download PNG\n                </AnchorButton>\n              </>\n            )}\n            {converting && (\n              <>\n                <NavbarDivider />\n                <div style={{ width: \"10rem\" }}>\n                  <ProgressBar value={progress} />\n                </div>\n              </>\n            )}\n            <NavbarDivider />\n            Duration:{\" \"}\n            {numeral(durationSecs > 0 ? durationSecs : 0).format(\"0.0\")}s\n          </NavbarGroup>\n        </Navbar>\n\n        <div\n          style={{\n            height: \"calc(100vh - 50px)\",\n            maxHeight: \"calc(100vh - 50px)\",\n            width: \"100vw\",\n            maxWidth: \"100vw\",\n            padding: \"1rem\",\n            backgroundColor: \"#293742\",\n          }}\n        >\n          <div\n            style={{\n              width: \"100%\",\n              maxWidth: \"100%\",\n              height: \"100%\",\n              maxHeight: \"100%\",\n              position: \"relative\",\n            }}\n            ref={videoRef as any}\n          >\n            <div\n              style={{\n                position: \"absolute\",\n                left: videoLeft,\n                top: videoTop,\n                width: videoWidth,\n                height: videoHeight,\n                pointerEvents: \"none\",\n              }}\n            >\n              {cropping && <ResizeDemo onCrop={onCrop} />}\n            </div>\n            {chunksUrl ? (\n              <Video chunksUrl={chunksUrl} />\n            ) : (\n              <NonIdealState\n                title=\"Nothing on tape yet\"\n                description=\"Record something\"\n                icon=\"warning-sign\"\n                action={\n                  !recording ? (\n                    <Button\n                      disabled={recording}\n                      onClick={startCapture}\n                      icon=\"record\"\n                    >\n                      Record\n                    </Button>\n                  ) : undefined\n                }\n              ></NonIdealState>\n            )}\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import gifshot from \"gifshot\";\n\nexport const exportGif = (\n  chunks: any[],\n  startTime: number,\n  stopTime: number,\n  screenWidth: number,\n  screenHeight: number,\n  onImageComplete: any,\n  onImageProgress: any,\n  gifWidth: number\n) => {\n  const scaleFactor = gifWidth / screenWidth;\n  const gifHeight = scaleFactor * screenHeight;\n  const durationMillis = 1.0 * (stopTime - startTime);\n  const framesPerSecond = 5;\n  const frameDuration = 10.0 / framesPerSecond;\n  const numFrames = Math.trunc((framesPerSecond * durationMillis) / 1000.0);\n  const interval = 1.0 / framesPerSecond;\n\n  onImageProgress(0);\n  gifshot.createGIF(\n    {\n      video: chunks,\n      gifWidth,\n      gifHeight,\n      numFrames,\n      interval,\n      frameDuration,\n      progressCallback: onImageProgress,\n    },\n    function (obj: any) {\n      if (!obj.error) {\n        var image = obj.image;\n        onImageComplete(image);\n      }\n    }\n  );\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
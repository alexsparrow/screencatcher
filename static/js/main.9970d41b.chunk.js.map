{"version":3,"sources":["export/exportPng.ts","components/Toolbar.tsx","components/Cropper.tsx","components/Video.tsx","state.ts","App.tsx","utils/useContainerDimensions.tsx","export/exportGif.ts","serviceWorker.ts","index.tsx"],"names":["exportPng","video","x","y","width","height","targetWidth","targetHeight","callback","canvas","document","createElement","context","getContext","startTime","Date","now","lastTime","frames","dels","play","onloadeddata","capture","timeSinceLastFrame","drawImage","imageData","getImageData","push","data","paused","requestAnimationFrame","UPNG","encode","Toolbar","state","dispatch","startCapture","stopCapture","durationSecs","onExportGif","onExportPng","progress","base64","btoa","Uint8Array","png","reduce","byte","String","fromCharCode","disabled","isRecording","onClick","icon","align","Alignment","RIGHT","type","minimal","content","text","isConverting","map","key","gifWidth","gif","download","href","target","style","value","numeral","format","Reactable","reactable","props","ref","getRef","position","left","top","touchAction","borderWidth","borderColor","borderStyle","pointerEvents","onCrop","onCropCancel","Cropper","onCancel","React","useState","coordinate","setCoordinate","resizable","edges","right","bottom","modifiers","interact","restrictRect","restriction","draggable","onDragMove","event","prev","dx","dy","onResizeMove","e","rect","deltaRect","Video","chunksUrl","autoPlay","controls","maxHeight","maxWidth","src","undefined","initialState","chunks","screenDimensions","isCropping","cropDimensions","reducer","action","chunk","URL","createObjectURL","captureStream","getVideoTracks","getSettings","dimensions","captureDisplay","displayMediaOptions","a","navigator","mediaDevices","getDisplayMedia","console","error","cursor","audio","App","useReducer","mediaRecorder","setMediaRecorder","setStartTime","stopTime","setStopTime","currentTime","setCurrentTime","setProgress","_mediaRecorder","MediaRecorder","ondataavailable","onstop","start","stop","videoRef","useRef","myRef","getDimensions","current","offsetWidth","offsetHeight","setDimensions","useEffect","handleResize","window","addEventListener","removeEventListener","useContainerDimensions","screenWidth","screenHeight","browserAspectRatio","videoAspectRatio","videoLeft","videoTop","videoWidth","videoHeight","scaledHeight","scaledWidth","setTimeout","className","onImageComplete","onImageProgress","gifHeight","durationMillis","numFrames","Math","trunc","gifshot","createGIF","interval","frameDuration","progressCallback","obj","image","exportGif","img","vid","scaleFactorX","scaleFactorY","round","padding","backgroundColor","title","description","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.9970d41b.chunk.js","sourcesContent":["import UPNG from \"upng-js\";\n\nexport const exportPng = (\n  video: HTMLVideoElement,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  targetWidth: number,\n  targetHeight: number,\n  callback: any\n) => {\n  const interval = 100;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = targetWidth;\n  canvas.height = targetHeight;\n  const context = canvas.getContext(\"2d\");\n\n  let startTime = Date.now();\n  let lastTime = startTime;\n\n  let frames: any[] = [];\n  let dels: number[] = [];\n\n  const capture = () => {\n    const timeSinceLastFrame = Date.now() - lastTime;\n    if (timeSinceLastFrame > interval) {\n      context?.drawImage(video, x, y, width, height, 0, 0, targetWidth, targetHeight);\n      const imageData = context?.getImageData(0, 0, targetWidth, targetHeight);\n      lastTime = Date.now();\n\n      frames.push(imageData?.data);\n      dels.push(timeSinceLastFrame);\n    }\n\n    if (!video.paused && Date.now() - startTime < 30000) {\n      requestAnimationFrame(capture);\n    } else {\n      callback(UPNG.encode(frames, targetWidth, targetHeight, 255, dels));\n    }\n  };\n\n  video.play();\n  video.onloadeddata = () => {\n    startTime = Date.now();\n    capture();\n  };\n};","import React from \"react\";\nimport {\n  MenuItem,\n  Menu,\n  NavbarDivider,\n  Popover,\n  NavbarGroup,\n  Navbar,\n  Button,\n  ProgressBar,\n  NavbarHeading,\n  Alignment,\n  MenuDivider,\n} from \"@blueprintjs/core\";\nimport numeral from \"numeral\";\nimport { State, Action } from \"../state\";\n\nexport const Toolbar = ({\n  state,\n  dispatch,\n  startCapture,\n  stopCapture,\n  durationSecs,\n  onExportGif,\n  onExportPng,\n  progress,\n}: {\n  state: State;\n  dispatch: React.Dispatch<Action>;\n  startCapture: any;\n  stopCapture: any;\n  durationSecs: number;\n  onExportGif: any;\n  onExportPng: any;\n  progress: number;\n}) => {\n  const base64 = btoa(\n    new Uint8Array(state.png).reduce(\n      (data, byte) => data + String.fromCharCode(byte),\n      \"\"\n    )\n  );\n\n  const imageWidths = [256, 512, 1024, 2048];\n\n  return (\n    <Navbar>\n      <NavbarGroup>\n        <NavbarHeading>\n          <h3>screencatcher</h3>\n        </NavbarHeading>\n        <Button\n          disabled={state.isRecording}\n          onClick={startCapture}\n          icon=\"record\"\n        >\n          Record\n        </Button>\n        <Button disabled={!state.isRecording} onClick={stopCapture} icon=\"stop\">\n          Stop\n        </Button>\n      </NavbarGroup>\n\n      <NavbarGroup align={Alignment.RIGHT}>\n        <Button\n          icon=\"zoom-to-fit\"\n          onClick={() => dispatch({ type: \"startCropping\" })}\n        >\n          Crop (PNG Only)\n        </Button>\n        <NavbarDivider />\n        <Popover\n          minimal\n          content={\n            <Menu>\n              <MenuItem\n                text=\"Export to PNG\"\n                disabled={state.isConverting}\n                onClick={onExportPng}\n              />\n              <MenuItem\n                text=\"Export to GIF\"\n                disabled={state.isConverting}\n                onClick={onExportGif}\n              />\n              <MenuDivider />\n\n              <MenuItem text=\"Image Width\">\n                {imageWidths.map((width: number) => (\n                  <MenuItem\n                    key={width}\n                    text={`${width}`}\n                    icon={state.gifWidth === width ? \"tick\" : null}\n                    onClick={() => dispatch({ type: \"setGifWidth\", width })}\n                  />\n                ))}\n              </MenuItem>\n            </Menu>\n          }\n        >\n          <Button icon=\"export\" text=\"Export...\" />\n        </Popover>\n        {(state.png || state.gif) && (\n          <Popover\n            minimal\n            content={\n              <Menu>\n                <MenuItem\n                  text=\"Download PNG\"\n                  download=\"screencatcher.png\"\n                  href={`data:image/png;base64,${base64}`}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!state.png}\n                />\n                <MenuItem\n                  text=\"Download GIF\"\n                  download=\"screencatcher.gif\"\n                  href={state.gif}\n                  target=\"_blank\"\n                  icon=\"download\"\n                  disabled={!state.gif}\n                />\n              </Menu>\n            }\n          >\n            <Button icon=\"download\" text=\"Download...\" />\n          </Popover>\n        )}\n        {state.isConverting && (\n          <>\n            <NavbarDivider />\n            <div style={{ width: \"10rem\" }}>\n              <ProgressBar value={progress} />\n            </div>\n          </>\n        )}\n        <NavbarDivider />\n        Duration: {numeral(durationSecs > 0 ? durationSecs : 0).format(\"0.0\")}s\n      </NavbarGroup>\n    </Navbar>\n  );\n};\n","import React from \"react\";\nimport { Button } from \"@blueprintjs/core\";\nimport reactable from \"reactablejs\";\nimport interact from \"interactjs\";\n\nconst Demo = (props: any) => (\n  <div\n    ref={props.getRef}\n    style={{\n      position: \"absolute\",\n      left: props.x,\n      top: props.y,\n      width: props.width,\n      height: props.height,\n      touchAction: \"none\",\n      borderWidth: 5,\n      borderColor: \"red\",\n      borderStyle: \"solid\",\n      pointerEvents: \"all\",\n    }}\n  >\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      {props.x},{props.y},{props.width},{props.height}{\" \"}\n      <Button\n        onClick={() =>\n          props.onCrop([props.x, props.y, props.width, props.height])\n        }\n      >\n        Crop\n      </Button>\n      <Button onClick={() => props.onCropCancel()}>Cancel</Button>\n    </div>\n  </div>\n);\nconst Reactable = reactable(Demo);\n\nexport const Cropper = ({\n  onCrop,\n  onCancel,\n}: {\n  onCrop: any;\n  onCancel: any;\n}) => {\n  const [coordinate, setCoordinate] = React.useState({\n    x: 0,\n    y: 0,\n    width: 300,\n    height: 200,\n  });\n  return (\n    <Reactable\n      onCrop={onCrop}\n      onCropCancel={onCancel}\n      resizable={{\n        edges: { left: true, right: true, bottom: true, top: true },\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      draggable={{\n        modifiers: [\n          interact.modifiers.restrictRect({\n            restriction: \"parent\",\n          }),\n        ],\n      }}\n      onDragMove={(event: any) =>\n        setCoordinate((prev: any) => ({\n          x: prev.x + event.dx,\n          y: prev.y + event.dy,\n          width: prev.width,\n          height: prev.height,\n        }))\n      }\n      onResizeMove={(e: any) => {\n        const { width, height } = e.rect;\n        const { left, top } = e.deltaRect;\n        setCoordinate((prev) => {\n          return {\n            x: prev.x + left,\n            y: prev.y + top,\n            width,\n            height,\n          };\n        });\n      }}\n      {...coordinate}\n    />\n  );\n};\n","import React from \"react\";\n\nexport const Video = ({ chunksUrl }: { chunksUrl: any }) => {\n  return (\n    <video\n      autoPlay\n      controls\n      style={{\n        maxHeight: \"100%\",\n        height: \"100%\",\n        maxWidth: \"100%\",\n        width: \"100%\",\n      }}\n      src={chunksUrl ? chunksUrl : undefined}\n    />\n  );\n};","export interface State {\n  chunks: any[];\n  chunksUrl: string;\n  isRecording: boolean;\n  isConverting: boolean;\n  screenDimensions: number[] | null;\n  png: any | null;\n  gif: any | null;\n  gifWidth: number;\n  isCropping: boolean;\n  cropDimensions: number[] | null;\n}\n\ninterface StartRecording {\n  type: \"startRecording\";\n}\n\ninterface RecordChunk {\n  type: \"recordChunk\";\n  chunk: any;\n}\n\ninterface StopRecording {\n  type: \"stopRecording\";\n  captureStream: any;\n}\n\ninterface StartExport {\n  type: \"startExport\";\n}\n\ninterface EndExport {\n  type: \"endExport\";\n  png?: any;\n  gif?: any;\n}\n\ninterface SetGifWidth {\n  type: \"setGifWidth\";\n  width: number;\n}\n\ninterface StartCropping {\n    type: \"startCropping\";\n}\n\ninterface EndCropping {\n    type: \"endCropping\";\n    dimensions?: number[];\n}\n\nexport type Action =\n  | StartRecording\n  | RecordChunk\n  | StopRecording\n  | StartExport\n  | EndExport\n  | SetGifWidth\n  | StartCropping\n  | EndCropping\n  ;\n\nexport const initialState: State = {\n  chunks: [],\n  chunksUrl: \"\",\n  isRecording: false,\n  isConverting: false,\n  screenDimensions: null,\n  png: null,\n  gif: null,\n  gifWidth: 1024,\n  isCropping: false,\n  cropDimensions: null,\n};\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"startRecording\":\n      return {\n        ...state,\n        isRecording: true,\n      };\n\n    case \"recordChunk\":\n      return {\n        ...state,\n        chunks: [...state.chunks, action.chunk],\n      };\n    case \"stopRecording\":\n      return {\n        ...state,\n        isRecording: false,\n        chunksUrl: URL.createObjectURL(state.chunks[0]),\n        screenDimensions: [\n          action.captureStream.getVideoTracks()[0].getSettings().width,\n          action.captureStream.getVideoTracks()[0].getSettings().height,\n        ],\n      };\n    case \"startExport\":\n      return {\n        ...state,\n        isConverting: true,\n      };\n    case \"endExport\":\n      return {\n        ...state,\n        isConverting: false,\n        png: action.png,\n        gif: action.gif,\n      };\n\n    case \"setGifWidth\":\n      return {\n        ...state,\n        gifWidth: action.width,\n      };\n\n    case \"startCropping\":\n        return {\n            ...state,\n            isCropping: true\n        };\n\n    case \"endCropping\":\n        return {\n          ...state,\n          isCropping: false,\n          cropDimensions: action.dimensions\n            ? action.dimensions\n            : state.cropDimensions,\n        };\n  }\n\n  return state;\n};\n","import React, { useState, useEffect, useRef, useReducer } from \"react\";\nimport \"./App.css\";\nimport { Button, NonIdealState } from \"@blueprintjs/core\";\nimport { exportPng } from \"./export/exportPng\";\nimport { exportGif } from \"./export/exportGif\";\nimport { Toolbar } from \"./components/Toolbar\";\nimport { useContainerDimensions } from \"./utils/useContainerDimensions\";\nimport { Cropper } from \"./components/Cropper\";\nimport { Video } from \"./components/Video\";\nimport { reducer, initialState } from \"./state\";\n\nasync function captureDisplay(\n  displayMediaOptions: any\n): Promise<MediaStream | null> {\n  let captureStream = null;\n\n  try {\n    captureStream = await navigator.mediaDevices.getDisplayMedia(\n      displayMediaOptions\n    );\n  } catch (err) {\n    console.error(\"Error: \" + err);\n    return null;\n  }\n  return captureStream;\n}\n\nconst displayMediaOptions = {\n  video: {\n    cursor: \"always\",\n  },\n  audio: false,\n};\n\nconst App = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [mediaRecorder, setMediaRecorder] = useState<any>(null);\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [stopTime, setStopTime] = useState<number | null>(null);\n  const [currentTime, setCurrentTime] = useState<number>(Date.now());\n  const [progress, setProgress] = useState(0);\n\n  const startCapture = async () => {\n    const captureStream = await captureDisplay(displayMediaOptions);\n\n    if (!captureStream) {\n      return;\n    }\n\n    const _mediaRecorder = new MediaRecorder(captureStream);\n    dispatch({ type: \"startRecording\" });\n\n    _mediaRecorder.ondataavailable = (e: any) =>\n      dispatch({ type: \"recordChunk\", chunk: e.data });\n\n    _mediaRecorder.onstop = () => {\n      dispatch({ type: \"stopRecording\", captureStream });\n    };\n\n    _mediaRecorder.start();\n    setStartTime(Date.now());\n    setMediaRecorder(_mediaRecorder);\n  };\n\n  const stopCapture = async () => {\n    mediaRecorder.stop();\n    setStopTime(Date.now());\n  };\n\n  const videoRef = useRef();\n  const { width, height } = useContainerDimensions(videoRef);\n  const screenWidth = state.screenDimensions?.[0];\n  const screenHeight = state.screenDimensions?.[1];\n\n  const browserAspectRatio = width / height;\n  const videoAspectRatio = screenWidth! / screenHeight!;\n\n  let videoLeft = 0,\n    videoTop = 0,\n    videoWidth = width,\n    videoHeight = height;\n\n  if (videoAspectRatio > browserAspectRatio) {\n    const scale = width / screenWidth!;\n    const scaledHeight = scale * screenHeight!;\n\n    videoTop = 0.5 * (height - scaledHeight);\n    videoHeight = scaledHeight;\n  } else if (browserAspectRatio > videoAspectRatio) {\n    const scale = height / screenHeight!;\n    const scaledWidth = scale * screenWidth!;\n\n    videoLeft = 0.5 * (width - scaledWidth);\n    videoWidth = scaledWidth;\n  }\n\n  const onExportPng = () => {\n    const vid = document.createElement(\"video\");\n    vid.src = state.chunksUrl;\n    vid.width = screenWidth!;\n    vid.height = screenHeight!;\n    dispatch({ type: \"startExport\" });\n\n    const scaleFactorX = (1.0 * screenWidth!) / width;\n    const scaleFactorY = (1.0 * screenHeight!) / height;\n    const cropDimensions = state.cropDimensions;\n\n    exportPng(\n      vid,\n      cropDimensions ? Math.round(cropDimensions[0] * scaleFactorX) : 0,\n      cropDimensions ? Math.round(cropDimensions[1] * scaleFactorY) : 0,\n      cropDimensions\n        ? Math.round(cropDimensions[2] * scaleFactorX)\n        : screenWidth!,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : screenHeight!,\n      cropDimensions ? Math.round(cropDimensions[2] * scaleFactorX) : state.gifWidth,\n      cropDimensions\n        ? Math.round(cropDimensions[3] * scaleFactorY)\n        : (screenHeight! * state.gifWidth) / screenWidth!,\n      (png: any) => dispatch({ type: \"endExport\", png })\n    );\n  };\n\n  const onCrop = (dimensions: number[]) => dispatch({\n    type: \"endCropping\",\n    dimensions\n  });\n\n  const onCropCancel = () =>\n    dispatch({\n      type: \"endCropping\",\n    });\n\n  useEffect(() => {\n    setTimeout(() => setCurrentTime(Date.now()), 1000);\n  }, [currentTime]);\n\n  const durationSecs =\n    ((stopTime ? stopTime : currentTime) -\n      (startTime ? startTime : currentTime)) /\n    1000.0;\n\n  const onExportGif = () => {\n    dispatch({ type: \"startExport\" });\n    exportGif(\n      state.chunks,\n      startTime!,\n      stopTime!,\n      screenWidth!,\n      screenHeight!,\n      (img: any) =>\n        dispatch({\n          type: \"endExport\",\n          gif: img,\n        }),\n      setProgress,\n      state.gifWidth\n    );\n  };\n\n  return (\n    <div className=\"App\">\n      <main className=\"bp3-dark\">\n        <Toolbar\n          state={state}\n          dispatch={dispatch}\n          durationSecs={durationSecs}\n          onExportGif={onExportGif}\n          onExportPng={onExportPng}\n          progress={progress}\n          startCapture={startCapture}\n          stopCapture={stopCapture}\n        />\n        <div\n          style={{\n            height: \"calc(100vh - 50px)\",\n            maxHeight: \"calc(100vh - 50px)\",\n            width: \"100vw\",\n            maxWidth: \"100vw\",\n            padding: \"1rem\",\n            backgroundColor: \"#293742\",\n          }}\n        >\n          <div\n            style={{\n              width: \"100%\",\n              maxWidth: \"100%\",\n              height: \"100%\",\n              maxHeight: \"100%\",\n              position: \"relative\",\n            }}\n            ref={videoRef as any}\n          >\n            <div\n              style={{\n                position: \"absolute\",\n                left: videoLeft,\n                top: videoTop,\n                width: videoWidth,\n                height: videoHeight,\n                pointerEvents: \"none\",\n              }}\n            >\n              {state.isCropping && (\n                <Cropper onCrop={onCrop} onCancel={onCropCancel} />\n              )}\n            </div>\n            {state.chunksUrl ? (\n              <Video chunksUrl={state.chunksUrl} />\n            ) : (\n              <NonIdealState\n                title={\n                  <>\n                    <p>\n                      screencatcher lets you record your desktop to an animated\n                      GIF or PNG.\n                    </p>\n                  </>\n                }\n                description={\n                  <>\n                    <p>\n                      It works entirely from your browser so doesn't require any\n                      other applications to be installed and doesn't share data\n                      with the outside world.\n                    </p>\n                  </>\n                }\n                icon=\"mobile-video\"\n                action={\n                  !state.isRecording ? (\n                    <Button onClick={startCapture} icon=\"record\">\n                      Click here to start recording\n                    </Button>\n                  ) : undefined\n                }\n              ></NonIdealState>\n            )}\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import { useEffect, useState } from \"react\";\n\nexport const useContainerDimensions = (myRef: any) => {\n  const getDimensions = () => ({\n    width: myRef.current.offsetWidth,\n    height: myRef.current.offsetHeight,\n  });\n\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setDimensions(getDimensions());\n    };\n\n    if (myRef.current) {\n      setDimensions(getDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [myRef]);\n\n  return dimensions;\n};\n","import gifshot from \"gifshot\";\n\nexport const exportGif = (\n  chunks: any[],\n  startTime: number,\n  stopTime: number,\n  screenWidth: number,\n  screenHeight: number,\n  onImageComplete: any,\n  onImageProgress: any,\n  gifWidth: number\n) => {\n  const scaleFactor = gifWidth / screenWidth;\n  const gifHeight = scaleFactor * screenHeight;\n  const durationMillis = 1.0 * (stopTime - startTime);\n  const framesPerSecond = 5;\n  const frameDuration = 10.0 / framesPerSecond;\n  const numFrames = Math.trunc((framesPerSecond * durationMillis) / 1000.0);\n  const interval = 1.0 / framesPerSecond;\n\n  onImageProgress(0);\n  gifshot.createGIF(\n    {\n      video: chunks,\n      gifWidth,\n      gifHeight,\n      numFrames,\n      interval,\n      frameDuration,\n      progressCallback: onImageProgress,\n    },\n    function (obj: any) {\n      if (!obj.error) {\n        var image = obj.image;\n        onImageComplete(image);\n      }\n    }\n  );\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport \"@blueprintjs/icons/lib/css/blueprint-icons.css\";\nimport \"@blueprintjs/core/lib/css/blueprint.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}